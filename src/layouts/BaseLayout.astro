---
import "tiny-css-reset";
import "../css/global.css";
import navigationData from "@data/navigation";
import Svg from "@jasikpark/astro-svg-loader";
import Nav from "@components/Nav/Nav.astro";

const { title, storyblokAttributes = [] } = Astro.props;
const navExpandedRoutes = navigationData.filter((x) => "children" in x);
const rootPathName = "/" + Astro.url.pathname.split("/")[1];
const isSubmenuOpen = Boolean(
	navExpandedRoutes.find((x) => x.url === rootPathName),
);
const currentYear = new Date().getFullYear();
---

<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" type="image/svg+xml" href="/favicon.svg" />
		<link
			rel="preconnect"
			href="https://a2-us.storyblok.com/"
			crossorigin
		/>
		<link rel="stylesheet" href="/fonts.css" />
		<slot name="head" />
		<meta name="viewport" content="width=device-width" />
		<meta name="generator" content={Astro.generator} />
		<title>{title ? `${title} - Bapharia.edu` : "Bapharia.edu"}</title>
		<script is:inline>
			window.addEventListener("load", () => {
				if ("serviceWorker" in navigator) {
					navigator.serviceWorker.register("/service-worker.js").then(
						(registration) =>
							console.log(
								"Service worker registration succeeded:",
								registration,
							),
						(error) =>
							console.error(
								`Service worker registration failed: ${error}`,
							),
					);

					if (navigator.serviceWorker.controller) {
						navigator.serviceWorker.controller.postMessage(
							"cleanup",
						);
					}
				}
			});
		</script>
	</head>
	<body>
		<div id="root" class:list={[{ "submenu-expanded": isSubmenuOpen }]}>
			<div class="contents" aria-owns="main-skip-link"></div>
			<header>
				<Nav />
			</header>
			<div class="main-region">
				<main id="main" {...storyblokAttributes}>
					<div class="stack stack-space-xs text-0">
						<slot />
						<a
							id="main-skip-link"
							href="#main"
							class="skip-link button visually-hidden-onblur"
							tabindex="1"
						>
							Skip to content
						</a>
					</div>
				</main>
			</div>
			<footer>
				<div class="flex justify-center">
					<Svg src={import("@assets/logo vertical.svg?raw")} />
				</div>
				<p class="max-is-none text--1 text-center">
					Copyright © 2023–{currentYear}
				</p>
			</footer>
		</div>
	</body>
</html>

<style>
	.skip-link {
		border-radius: var(--border-radius-s);
		inset-block-start: calc(
			var(--main-region-padding) + var(--nav-toggle-content-offset)
		);
		margin: 8px;
		position: absolute;
	}

	footer {
		align-items: center;
		border-block-start: 1px solid var(--color-separator-weak);
		display: flex;
		flex-direction: column;
		margin-block: var(--space-l-rem);
		padding-block-start: var(--space-l-rem);
		padding-inline-start: calc(
			var(--sidebar-width) + var(--sidebar-content-offset)
		);
		padding-inline-end: var(--sidebar-content-offset);
	}

	.footer-links {
		column-gap: var(--space-xl-rem);
		display: flex;
		flex-flow: row wrap;
		font-size: 1rem;
		row-gap: var(--space-s-rem);
	}

	.footer-links a {
		color: var(--color-text-regular);
	}

	@container body (min-inline-size: 30rem) {
		footer {
			border: none;
			padding-block-start: 0;
		}
	}
</style>

<script is:inline>
	document.body.addEventListener(
		"error",
		(event) => {
			if (event.target.tagName.toLowerCase() === "img") {
				event.target.classList.add("w-auto");
			}
		},
		true,
	);

	(() => {
		// To guard against the case that this polyfill might be included more than once
		// we must ensure that the ID generating function is a singleton
		// to guarantee that no duplicated IDs are generated - however slim the chance might be.
		// The IDs are unique in the current javascript runtime context.
		// The IDs are constructed from the following parts:
		// - a timestamp
		// - the current value of a counter, incremented after each created ID
		// - a static prefix
		// Even if two IDs are generated within the same milisecond the increased counter ensures
		// that they cannot clash.

		const polyfill_key = "bae45330cd3d4e0e96b60d26b57009b5";
		const polyfill = Symbol.for(polyfill_key);
		window[polyfill] =
			window[polyfill] ??
			(() => {
				let count = 0;
				return {
					createID: () => `${polyfill_key}-${Date.now()}-${count++}`,
				};
			})();
		const createID = window[polyfill].createID;

		class ContainerQueryListEvent extends Event {
			container;

			matches;

			constructor(type) {
				super(type);
			}
		}
		class ContainerQueryList extends EventTarget {
			container;

			matches;

			constructor(element, containerQueryString) {
				super();
				this.container = containerQueryString;
				const unique_name = "container-query-observer-" + createID();
				const markerAttribute = `data-${unique_name}`;
				element.setAttribute(markerAttribute, "");
				const sentinelProperty = `--${unique_name}`;
				const containerQuerySheet = new CSSStyleSheet();
				const css = `
      @property ${sentinelProperty} {
        syntax: '<custom-ident>';
        inherits: false;
        initial-value: --false;
      }
      @container ${containerQueryString} { [${markerAttribute}] { ${sentinelProperty}: --true; } }`;

				containerQuerySheet.replaceSync(css);
				document.adoptedStyleSheets = [
					...document.adoptedStyleSheets,
					containerQuerySheet,
				];
				const style = getComputedStyle(element);
				this.matches =
					style.getPropertyValue(sentinelProperty) === "--true";

				this.#startObserving(
					sentinelProperty,
					containerQueryString,
					element,
				);
			}

			#startObserving(
				sentinelProperty,
				containerQueryString,
				observedElement,
			) {
				const _callback = (values) => {
					if (sentinelProperty in values) {
						const matches = values[sentinelProperty] === "--true";
						this.matches = matches;
						// raise 'change' event
						const event = new ContainerQueryListEvent("change");
						event.matches = matches;
						event.container = containerQueryString;
						this.dispatchEvent(event);
					}
				};

				const _previousValues = {};

				observedElement.style.setProperty(
					"transition",
					`${sentinelProperty} 0.001ms step-start`,
				);
				observedElement.style.setProperty(
					"transition-behavior",
					"allow-discrete",
				);
				const onTransitionRun = (e) => {
					const targetElement = e.target;

					if (observedElement === targetElement) {
						const computedStyle = getComputedStyle(targetElement);
						const changes = {};
						const currentValue =
							computedStyle.getPropertyValue(sentinelProperty);
						const previousValue = _previousValues[sentinelProperty];
						const hasChanged = currentValue !== previousValue;

						if (hasChanged) {
							changes[sentinelProperty] = currentValue;
							_previousValues[sentinelProperty] = currentValue;
							_callback(changes);
						}
					}
				};
				observedElement.addEventListener(
					"transitionrun",
					onTransitionRun,
				);

				// init _previousValues
				const computedStyle = getComputedStyle(observedElement);
				const currentValue =
					computedStyle.getPropertyValue(sentinelProperty);
				_previousValues[sentinelProperty] = currentValue;
			}
		}

		if (Element.prototype.matchContainer) return;

		function matchContainer(containerQueryString) {
			return new ContainerQueryList(this, containerQueryString);
		}
		Element.prototype.matchContainer = matchContainer;
	})();
</script>

<script is:inline type="speculationrules">
	{
		"prerender": [
			{
				"where": { "href_matches": "/*" },
				"eagerness": "moderate"
			}
		]
	}
</script>
